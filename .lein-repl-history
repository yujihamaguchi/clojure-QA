(clojure.string/uppper-case "a")
(clojure.string/upper-case "a")
(clojure.string/upper-case \a)
(clojure.string/replace "abc-de-fg" #"-[a-z]" (fn [m] (str m "x")))
(Math/pow 2 3)
(Math/pow 16 2)
(doc int)
(doc halve)
(div 5 2)
(quot 5 2)
(rem 5 2)
(div 5 2)
(/ 5 2)
(Math/ceil (/ 5 2))
(take (Math/ceil (/ 5 2)) "ahoahoman")
(str 1234)
\1
(int \1)
(clojure.stirng/parse-int \1)
(Integer.parseInt \1)
(Integer/parseInt \1)
(exit)
(range 10)
(doc sqrt)
(str 10)
(str 99)
(map int (str 99))
(map read-string (str 99))
(map Character/parseInt (str 99))
(map Character/getNumericValue (str 99))
(read \1)
(read-string \1)
(str \1)
(Integer/parseInt "1")
((comp str Integer/parseInt) "1")
(Integer/parseInt "1")
((comp str str) "2")
((comp str Integer/parseInt) "1")
((comp str (fn [n] (Integer/parseInt n))) "1")
(read-string "11")
(doc zip)
(find-doc #"zip")
(map vector (range 10) "ahoaho")
(take 10 (iterate inc 0))
(take 10 (iterate Math/pow 0))
(take 10 (iterate (fn [n] (Math/pow n)) 0))
(Math/pow 2)
(Math/pow 1 2)
(take 10 (map (fn [n] (Math/pow 2 n)) (iterate inc 0)))
((fn [bs] (reduce +
                 (map (fn [n b] (* n (Integer/parseInt (str b))))
                      (map (fn [n] (Math/pow 2 n)) (iterate inc 0))
                      (reverse bs)))) "0")
(Integer/parseInt 0.0)
(int 0.0)
(:a {:a nil :b "aho"})
(doc nil?)
(doc contains?)
(doc take-nth)
(take-nth "ahoahoman")
(take-nth 2 (range 19))
(take-nth 2 (range 11)
)
(take-nth 2 (range 1 11))
(take-nth 1 (range 1 11))
(take-nth 3 (range 1 11))
(range 1 11)
(take-nth 2 (range 1 11))
(take-nth 2 (rest (range 1 11)))
(def x [20 / 2 + 2 + 4 + 8 - 6 - 10 * 9])
(take-nth 2 x)
(take-nth 2 (rest x))
((/ 20) 2)
(/ 20 2)
(doc reduce)
(def x '{a {p 1, q 2} b {m 3, n 4}})
(keys x)
(vals x)
(map (fn [[k v]] (cons k [v])) (vals x))
(map (fn [{k v}] (cons k [v])) (vals x))
(map (fn [y] y) (vals x))
(map (fn [y] y) {p 1, q 2})
(map (fn [y] y) '{p 1,q 2})
(map (fn [[x y]] (println "x: " x ",y: " y)) '{p 1, q 1})
(rest [10])
(rest [1 2])
(partition 2 '[38 + 48 - 2 / 2])
(partition 2 '[+ 48 - 2 / 2])
(doc reduce)
(doc hash-map)
(hash-map [1 2 3 4])
(apply hash-map [1 2 3 4])
(doc for)
(partition 2 [1 2 3])
(partition 2 1 [1 2 3])
(map (fn [[n m]] (+' n m)) (partition 2 1 [1 2 3]))
[1 (mapcat (fn [[n m]] (+' n m)) (partition 2 1 [1 2 3])) 3]
(mapcat (fn [[n m]] (+' n m)) (partition 2 1 [1 2 3]))
(map (fn [[n m]] (+' n m)) (partition 2 1 [1 2 3]))
‡H
(first [1 2 3])
(last [1 2 3])
(concat 1 2)
(concat [1] [2])
(vec (concat [1] [2]))
(concat [1] [2 3] [4])
(vec (concat [1] '(2 3) [4]))
(vector 1 '(2 3) 4)
(vector [1] '(2 3) [4])
(vector 1 (mapcat identity [2 3]) 4)
(mapcat identity [1 2])
(mapcat identity "aho")
(flatten [1 2 3])
(flatten [[1] 2 3])
(clojure.set/union #{#{\U} #{\s} #{\e \R \E} #{\P \L} #{\.})
(clojure.set/union #{#{\U} #{\s} #{\e \R \E} #{\P \L} #{\.}})
(apply clojure.set/union #{#{\U} #{\s} #{\e \R \E} #{\P \L} #{\.}})
(count (apply clojure.set/union #{#{\U} #{\s} #{\e \R \E} #{\P \L} #{\.}}))
(reduce (fn [n s] (+ n (count s))) 0 #{#{\U} #{\s} #{\e \R \E} #{\P \L} #{\.}})
(doc distinct?)
(hash-map 1 2)
(doc merge)
(doc zipmap)
(zipmap  [:a :b :c] (iterate inc 0))
(map vector [:a :b :c] (iterate inc 0))
(doc case)
(partition 2 1 #{1 2 3})
(count #{1 2 3})
(seq #{1 2 3})
(hash-set #{2 3} #{4 5})
(set [1 2])
(partition 1 1  #{:a 1})
(def x (partition 1 1  #{:a 1}))
(map set x)
(doc doall)
(use 'clj.core :reload)
(p85 #{1 2 3})
(clojure.set/union #{1 2} #{1} #{2})
(set #{1 2})
(hash-set #{1 2})
(clojure.math/combinations [1 2 3] 1)
(use 'clojure.math)
(set (first [1 2 3]))
(hash-set (first [1 2 3]))
(set (rest [1 2 3]))
(set [1 2 2 3])
(concat #{1 :a} #{})
(concat #{#{1 :a}} #{})
(concat #{1} #{})
(find-doc #"\?$")
(keyword? \a)
(keyword? :a)
(sprit-with keyword?  [:a 1 2 3 :b :c 4])
(split-with keyword? [:a 1 2 3 :b :c 4])
(reduce (partial split-with keyword?)  [:a 1 2 3 :b :c 4])
(reduce (partial split-with keyword?) [] [:a 1 2 3 :b :c 4])
(hash-map :a [1 2 3])
(conj {1 2 3 4} {5 6})
(assoc {1 2} 3 4)
(exit)
(rem 5 10)
(rem 1 2)
(Math/pow 10 0)
(take 10 (iterate #(Math/pow 10 %) 0))
(take 10 (iterate #(Math/pow 2 ) 0))
(take 10 (iterate #(Math/pow 2 %) 0))
(doc take-while)
(take-while #(< % 9) (iterate #(Math/pow 2 %) 0))
(Math/pow 2 0)
(Math/powr 2 1)
(Math/pow 2 1)
(Math/pow 2 2)
(take 4 (iterate #(Math/pow 2 %) 0))
(take 4 (iterate #(Math/pow 2 %) 1))
(take 4 (map #(Math/pow 2 %) (range)))
(take-while #(<= % 9) (map #(Math/pow 2 %) (range)))
(quot 9 2)
(quot 3 4)
(nth (__ [1]) 6)
(doc juxt
)
(doc partition-by)
(partition-by identity [1])
(doc repeat)
(take 10 (apply repeat [1 2 3]))
(take 10 (repeat [1 2 3]))
(doc cycle)
(take 10 (cycle [1 2 3]))
(doc reductions)
(doc reduce)
(min [1 2 3])
(apply min [1 2 3])
(doc juxt)
(reduce identity [1 1 1])
(reduce = [1 1 1])
(doc all?)
(doc all)
(find-doc #"\?$")
(distinct? [1 1 1])
(distinct? [1 2 1])
(distinct? [1 0.5])
(doc distinct?)
(distinct? [1 0.5 1])
(find-doc #"\?$")
(= 0.5 1)
(doc every?)
(doc and)
(doc flatten)
(flatten [[[[:a :b]]] [[:c :d]] [:e :f]])
(flatten ((1 2)((3 4)((((5 6)))))))
(flatten '((1 2)((3 4)((((5 6)))))))
(partition 2 '(1 2 3 4 5 6))
[[1]]
[1]
(seq [1])
((lowest-seq? [coll] (and (seq coll) (not (seq (first coll))))) ["No"])
((fn [coll] (and (seq coll) (not (seq (first coll))))) ["No"])
(seq ["No"])
(first ["No"])
(seq "No")
(coll? "No")
(defn lowest-seq? [coll] (and (seq coll) (not (coll? (first coll)))))
(lowest-seq? '(1 2))
(rest [1])
(seq (rest [1]))
(seq (rest [1 2]))
(use 'clj.core :reload)
((p158 (fn [a] (fn [b] (fn [c] (fn [d] (+ a b c d)))))) 1 2 3 4)
(def x ((p158 (fn [a] (fn [b] (fn [c] (fn [d] (+ a b c d)))))) 1 2 3 4))
(use 'clj.core :reload)
(def x ((p158 (fn [a] (fn [b] (fn [c] (fn [d] (+ a b c d)))))) 1 2 3 4))
(x 4)
(x)
(x 1 2 3 4)
(cons 1 2 3 )
(cons 1 [2])
(partial (fn [a] (fn [b] (fn [c] (fn [d] (+ a b c d)))))) 1))
((partial (fn [a] (fn [b] (* a b))) 2) 3)
(partial (partial (fn [a] (fn [b] (* a b))) 2) 3)
((partial (partial (fn [a] (fn [b] (* a b))) 2) 3))
(def f (fn [a] (fn [b] (* a b))))
(f 2)
((f 2) 3)
(((fn [a] (fn [b] (* a b))) 2) 3)
(def f2 (partial f 2))
(f2 3)
(take-while #(= 2 (mod % 3)) [2 3 5 7 11 13 17 19 23])
(filter #(= 2 (mod % 3)) [2 3 5 7 11 13 17 19 23])
(doc if-let)
(find-doc #"if-let")
(take-while "M" "MMMK")
(take-while #(= "M" M) "MMMK")
(take-while #(= "M" %) "MMMK")
(take-while #(= \M %) "MMMK")
(use 'core.clj :reload)
(use 'clj.core :reload)
(p104 "MMM")
(use 'clj.core :reload)
(p104 "MMM")
(re-seq #"^M+" "MMMKKK")
(use 'clj.core :reload)
(p104 "MMM")
(use 'clj.core :reload)
(p104 "DC")
(p104 "DCC")
(use 'clj.core :reload)
(p92 "DCC")
(p92 "XIV")
(drop 2 "XIV")
(seq (drop 2 "XIV"))
(re-seq #"^V+" (drop 2 "XIV"))
(re-seq #"^V+" (str (drop 2 "XIV")))
(re-seq #"^V+" "V")
(drop 2 "XIV")
(str (drop 2 "XIV"))
(apply str (drop 2 "XIV"))
(re-seq #"^V+" (apply str (drop 2 "XIV")))
(drop 2 "aaaaa")
(drop-while #(= \M %) "MMMMKKKKKK")
(exit)
(quot 1 1000)
(doc repeat)
(quot 30 1000)
(repeat 0 \M)
(clojure.set/difference #{1 2 3} #{1})
(first #{1 2 3})
(hash-set 1)
(vector 1 2 [])
[1 2 nil]
(use 'clj.core :reload)
(p103 3 #{0 1 2 3 4})
(pprint (p103 3 #{0 1 2 3 4}))
(p103 2 #{0 1 2})
(use 'clj.core :reload)
(p103 2 #{0 1 2})
(use 'clj.core :reload)
(p103 2 #{0 1 2})
(use 'clj.core :reload)
(p103 2 #{0 1 2})
(clojure.set/union #{1 0} #{0 1})
(def x '((0 (1) (2)) (1 (0) (2)) (2 (0) (1))))
x
(def y '(0 (1 (2) (3) (4))))
y
(tree-seq seq? identity y)
y
(use 'clj.core :reload)
(fnx x)
(use 'clj.core :reload)
(fnx x)
x
y
(cons (first x) (first (rest x)))
(map #(cons (first x) %) (rest x))
(def z '(0 (1 (2) (3) (4))))
z
(map #(cons (first z) %) (rest z))
(def z '(0 (1 (2) (3) (4)) (5 (6) (7) (8))))
(map #(cons (first z) %) (rest z))
(map #(cons (take-while 
(doc take-while)
(map #(cons (take-while (fn [x] (not (seq x))) z) %) (rest z))
(map #(cons (first z) %) (rest z))
 (map #(cons (first x) %) (rest x))
(map #(concat (take-while (fn [x] (not (seq x))) z) %) (rest z))
z
(take-while symbol? z)
(take-while #(not (seq %)) z)
(seq 0)
(seq? 0)
(take-while #(not (seq? %)) z)
(map #(concat (take-while (fn [x] (not (seq? x))) z) %) (rest z))
(concat 1 '(2 (3 4)))
(cons 1 '(2 (3 4)))
(cons 1 [2])
(concat [1] [2 [3 4]])
(cons 1 [[2 [3 4]]])
(concat [1] [[2 [3 4]]])
(concat [1] [[2 [3 4]]] [[2 [3 4]]])
(range 1 3)
(use 'clj.core :reload)
(rotate [1 2 3])
(use 'clj.core :reload)
(strct-tr [1 2 3])
(use 'clj.core :reload)
(strct-tr [1 2 3])
(clojure.math.combinatorics [1 2 3] 2)
(clojure.math.combinatorics/combinations [1 2 3] 2)
(use 'clj.core :reload)
(strct-tr 2 [1 2 3])
(strct-tr 3 [1 2 3])
(strct-tr 4 [1 2 3 4])
(pprint (strct-tr 4 [1 2 3 4]))
(use 'clj.core :reload)
(strct-tr 4 [1 2 3 4])
(strct-tr 3 [1 2 3 4])
(strct-tr 2 [1 2 3 4])
(use 'clj.core :reload)
(strct-tr 3 [1 2 3 4])
(use 'clj.core :reload)
(strct-tr 3 [1 2 3 4])
(use 'clj.core :reload)
(strct-tr 3 [1 2 3 4])
(strct-tr 2 [1 2 3 4])
(strct-tr 1[1 2 3 4])
(use 'clj.core :reload)
(cons-tr 3 [1 2 3 4])
(use 'clj.core :reload)
(cons-tr 3 [1 2 3 4])
(cons-tr 2 [1 2 3 4])
(doc walk)
(use 'clj.core :reload)
(cons-tr 3 [1 2 3 4])
(cons-tr 3 [1 2 3])
(walk-tr (cons-tr 3 [1 2 3]))
(use 'clj.core :reload)
(walk-tr (cons-tr 3 [1 2 3]))
(use 'clj.core :reload)
(walk-tr (cons-tr 3 [1 2 3]))
(rest '(1 (2 (3)) (3 (2))))
(use 'clj.core :reload)
(walk-tr (cons-tr 3 [1 2 3]))
(use 'clj.core :reload)
(walk-tr (cons-tr 3 [1 2 3]))
(use 'clj.core :reload)
(walk-tr (cons-tr 3 [1 2 3]))
(use 'clj.core :reload)
(walk-tr (cons-tr 3 [1 2 3]))
(rest '(1 (2 (3)) (3 (2))))
(doc flatten)
(flatten '(1 (2 (3)) (3 (2))))
(first (rest '(1 (2 (3)) (3 (2)))))
(walk-tr (first (rest '(1 (2 (3)) (3 (2))))))
(use 'clj.core :reload)
(walk-tr (first (rest '(1 (2 (3)) (3 (2))))))
(cons-tr 3 [1 2 3])
(rotate [1 2 3])
(map (partial cons-tr 3) (rotate [1 2 3]))
(tree-seq seq? identity (map (partial cons-tr 3) (rotate [1 2 3])))
(pprint (tree-seq seq? identity (map (partial cons-tr 3) (rotate [1 2 3]))))
(tree-seq next rest (map (partial cons-tr 3) (rotate [1 2 3])))
(pprint (tree-seq next rest (map (partial cons-tr 3) (rotate [1 2 3]))))
(tree-seq seq? rest (map (partial cons-tr 3) (rotate [1 2 3])))
(pprint (tree-seq seq? rest (map (partial cons-tr 3) (rotate [1 2 3]))))
(use 'clj.core :reload)
(walk-tr (first (rest '(1 (2 (3)) (3 (2))))))
(use 'clj.core :reload)
(walk-tr '(1 (2 (3)) (3 (2))))
(use 'clj.core :reload)
(walk-tr '(1 (2 (3)) (3 (2))))
(use 'clj.core :reload)
(cons-tr 2 [1 2 3])
(cons-tr 3 [1 2 3
)
(cons-tr 3 [1 2 3])
(cons 1 [2])
(use 'clj.core :reload)
(wakl-tr '(1 (2 (3)) (3 (2))))
(walk-tr '(1 (2 (3)) (3 (2))))
(walk-tr '(1 (2 (3)) (4 (5))))
(use 'clj.core :reload)
(walk-tr '(1 (2 (3)) (4 (5))))
(walk-tr '(1 (2 (3))))
(use 'clj.core :reload)
 (walk-tr '(1 (2 (3))))
(use 'clj.core :reload)
(walk-tr '(1 (2 (3))))
(use 'clj.core :reload)
(walk-tr '(1 (2 (3))))
(use 'clj.core :reload)
(walk-tr '(1 (2 (3))))
(use 'clj.core :reload)
(walk-tr '(1 (2 (3))))
(use 'clj.core :reload)
(walk-tr '(1 (2 (3)) (4 (5))))
(walk-tr '(1 (2 (3))))
(use 'clj.core :reload)
(walk-tr '(1 (2 (3))))
(walk-tr '(1 (2 (3)) (4 (5))))
(use 'clj.core :reload)
(walk-tr '(1 (2 (3))))
(cons 1 [2 3])
(cons 1 [[2 3]])
(use 'clj.core :reload)
(walk-tr '(1 (2 (3))))
(use 'clj.core :reload)
(walk-tr '(1 (2 (3))))
(use 'clj.core :reload)
(walk-tr '(1 (2 (3))))
(fn x [coll] (partial cons 1))
(defn x [coll] (partial cons 1))
(x [2 3])
((x [2 3]))
((partial cons 1) [2 3])
(use 'clj.core :reload)
(walk-tr '(1 (2 (3))))
(use 'clj.core :reload)
(walk-tr '(1 (2 (3))))
(use 'clj.core :reload)
(walk-tr '(1 (2 (3))))
(use 'clj.core :reload)
(walk-tr '(1 (2 (3))))
(use 'clj.core :reload)
(walk-tr '(1 (2 (3))))
(use 'clj.core :reload)
(walk-tr '(1 (2 (3))))
(use 'clj.core :reload)
(walk-tr '(1 (2 (3))))
(use 'clj.core :reload)
(walk-tr '(1 (2 (3))))
(use 'clj.core :reload)
 (walk-tr '(1 (2 (3))))
(rest '(1 (2 (3))))
(use 'clj.core :reload)
(walk-tr '(1 (2 (3))))
 (use 'clj.core :reload)
(walk-tr '(1 (2 (3))))
(concat [1] [2 3])
(use 'clj.core :reload)
(walk-tr '(1 (2 (3))))
(use 'clj.core :reload)
(walk-tr '(1 (2 (3))))
(use 'clj.core :reload)
(walk-tr '(1 (2 (3))))
(use 'clj.core :reload)
(walk-tr '(1 (2 (3))))
(walk-tr '(1 (2 (3)) (4 (5))))
(cons-tr 2 [1 2 3])
(walk-tr (cons-tr 2 [1 2 3]))
(cons-tr 2 [1 2 3 4])
(walk-tr (cons-tr 2 [1 2 3 4]))
(cons-tr 2 [1 2 3 4])
(walk-tr '(1 (2) (3) (4)))
(nil? 1)
(filter #(not (nil? %)) [1 2 nil 2])
 (use 'clj.core :reload)
(cons-tr 2 [1 2 3 4])
(walk-tr (cons-tr 2 [1 2 3 4]))
(cons-tr 2 [0 1 2])
(walk-tr (cons-tr 2 [0 1 2]))
